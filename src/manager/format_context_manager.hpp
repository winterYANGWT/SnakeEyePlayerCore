#ifndef FORMAT_CONTEXT_MANAGER_H
#define FORMAT_CONTEXT_MANAGER_H

extern "C"
{
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <libavdevice/avdevice.h>
}
#include <string>
#include <vector>
#include <queue>
#include <unordered_map>
#include <functional>
#include <thread>

#include "../util/util.h"
#include "../util/utils.h"
#include "../context/format_context.hpp"
#include "../thread/thread/base_thread.hpp"

class OSFFFormatContextManager
{
private:
    std::unordered_map<int, OSFFFormatContext *> osff_fmt_ctxs;

    std::function<int(int, void *, int)> push_data_cb;

    std::function<int(int, void *&, int)> pop_data_cb;

public:
    OSFFFormatContextManager(std::function<int(int, void *, int)> push_data_cb,
                             std::function<int(int, void *&, int)> pop_data_cb)
        : push_data_cb(push_data_cb),
          pop_data_cb(pop_data_cb) {}

    ~OSFFFormatContextManager();

    /**
     * @brief Open input and allocate format context
     * @param fmt_id Format ID generated by IDGenerator, used to identify format context
     * @param url Input URL
     * @param fmt Input format. if input is file or protocol, fmt can be nullptr, libavformat will try to guess format.
     *            but if input is device, fmt must be specified
     * @param options Options for input format
     * @return 0 on success, otherwise negative value on error
     */
    int open_input(int fmt_id,
                   std::string url,
                   const AVInputFormat *fmt = nullptr,
                   AVDictionary **options = nullptr);

    /**
     * @brief Open output and allocate format context
     * @param fmt_id Format ID generated by IDGenerator, used to identify format context
     * @param url Output URL
     * @param fmt Output format. if output is file or protocol, fmt can be nullptr, libavformat will try to guess format.
     *           but if output is device, fmt must be specified
     * @param options Options for output format
     * @return 0 on success, otherwise negative value on error
     */
    int open_output(int fmt_id,
                    std::string url,
                    const AVOutputFormat *fmt = nullptr,
                    AVDictionary **options = nullptr);

    // int add_input_device(int fmt_ctx_idx,
    //                      const std::string &audio_device_name,
    //                      const std::string &video_device_name,
    //                      AVDictionary *options = nullptr);

    /**
     * @brief Get format context by format ID
     * @param fmt_id Format ID generated by IDGenerator, used to identify format context
     * @param fmt_ctx format context
     * @return 0 on success, otherwise negative value on error
     */
    int get_format_context(int fmt_id,
                           OSFFFormatContext *&fmt_ctx);

    /**
     * @brief Add output stream to format context
     * @param fmt_id Format ID generated by IDGenerator, used to identify format context
     * @param codec_ctx Encoder codec context, used to create output stream.
     *                  Codec context must be initialized before calling this function
     * @param ostrm_id Output stream ID, which is in-format stream ID not generated by IDGenerator
     * @return 0 on success, otherwise negative value on error
     */
    int add_output_stream(int fmt_id,
                          AVCodecContext *codec_ctx,
                          int &ostrm_id);

    int delete_output_stream(int fmt_id);

    int get_stream(int fmt_id,
                   int in_fmt_strm_id,
                   AVStream *&strm);

    int build_threads(std::vector<OSFFBaseThread *> &threads);
};

#endif // FORMAT_CONTEXT_MANAGER_H